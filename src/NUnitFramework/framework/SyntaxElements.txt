#
# Prefix Operators
#
/// <summary>
/// Returns a ConstraintExpression that negates any
/// following constraint.
/// </summary>
Type: ConstraintExpression
Gen: Is.Not=>new ConstraintExpression().Not
Gen: Has.No=>new ConstraintExpression().Not
Gen: ConstraintFactory.Not=>Is.Not
Gen: ConstraintFactory.No=>Has.No
Gen: ConstraintExpression.Not=>this.Append(new NotOperator())
Gen: ConstraintExpression.No=>this.Append(new NotOperator())
%
/// <summary>
/// Returns a ConstraintExpression, which will apply
/// the following constraint to all members of a collection,
/// succeeding if all of them succeed.
/// </summary>
Type: ConstraintExpression
Gen: Is.All=>new ConstraintExpression().All
Gen: Has.All=>new ConstraintExpression().All
Gen: Text.All=>new ConstraintExpression().All
Gen: ConstraintFactory.All=>Is.All
Gen: ConstraintExpression.All=>this.Append(new AllOperator())
%
/// <summary>
/// Returns a ConstraintExpression, which will apply
/// the following constraint to all members of a collection,
/// succeeding if at least one of them succeeds.
/// </summary>
Type: ConstraintExpression
Gen: Has.Some=>new ConstraintExpression().Some
Gen: ConstraintFactory.Some=>Has.Some
Gen: ConstraintExpression.Some=>this.Append(new SomeOperator())
%
/// <summary>
/// Returns a ConstraintExpression, which will apply
/// the following constraint to all members of a collection,
/// succeeding if all of them fail.
/// </summary>
Type: ConstraintExpression
Gen: Has.None=>new ConstraintExpression().None
Gen: ConstraintFactory.None=>Has.None
Gen: ConstraintExpression.None=>this.Append(new NoneOperator())
%
/// <summary>
/// Returns a new PropertyConstraintExpression, which will either
/// test for the existence of the named property on the object
/// being tested or apply any following constraint to that property.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Property(string name)=>new ConstraintExpression().Property(name)
Gen: ConstraintFactory.Property(string name)=>Has.Property(name)
Gen: ConstraintExpression.Property(string name)=>this.Append(new PropOperator(name))
%
/// <summary>
/// Returns a new ConstraintExpression, which will apply the following
/// constraint to the Length property of the object being tested.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Length=>Property("Length")
Gen: ConstraintFactory.Length=>Has.Length
Gen: ConstraintExpression.Length=>Property("Length")
%
/// <summary>
/// Returns a new ConstraintExpression, which will apply the following
/// constraint to the Count property of the object being tested.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Count=>Property("Count")
Gen: ConstraintFactory.Count=>Has.Count
Gen: ConstraintExpression.Count=>Property("Count")
%
/// <summary>
/// Returns a new ConstraintExpression, which will apply the following
/// constraint to the Message property of the object being tested.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Message=>Property("Message")
Gen: ConstraintFactory.Message=>Has.Message
Gen: ConstraintExpression.Message=>Property("Message")
%
/// <summary>
/// Returns a new AttributeConstraint checking for the
/// presence of a particular attribute on an object.
/// </summary>
Type: ResolvableConstraintExpression
Gen: Has.Attribute(Type expectedType)=>new ConstraintExpression().Attribute(expectedType)
Gen: Has.Attribute<T>()=>Attribute(typeof(T))
Gen: ConstraintFactory.Attribute(Type expectedType)=>Has.Attribute(expectedType)
Gen: ConstraintFactory.Attribute<T>()=>Attribute(typeof(T))
Gen: ConstraintExpression.Attribute(Type expectedType)=>this.Append(new AttributeOperator(expectedType))
Gen: ConstraintExpression.Attribute<T>()=>Attribute(typeof(T))
%
/// <summary>
/// Creates a constraint specifying an expected exception
/// </summary>
Type: ResolvableConstraintExpression
Gen: Throws.Exception=>new ConstraintExpression().Append(new ThrowsOperator())
%
/// <summary>
/// Creates a constraint specifying that no exception is thrown
/// </summary>
Type: ThrowsNothingConstraint
Gen: Throws.Nothing=>new ThrowsNothingConstraint()
%
/// <summary>
/// Creates a constraint specifying the exact type of exception expected
/// </summary>
Type: ExactTypeConstraint
Gen: Throws.TypeOf(Type expectedType)=>Exception.TypeOf(expectedType)
Gen: Throws.TypeOf<T>()=>TypeOf(typeof(T))
%
/// <summary>
/// Creates a constraint specifying the type of exception expected
/// </summary>
Type: InstanceOfTypeConstraint
Gen: Throws.InstanceOf(Type expectedType)=>Exception.InstanceOf(expectedType)
Gen: Throws.InstanceOf<T>()=>InstanceOf(typeof(T))
%
/// <summary>
/// With is currently a NOP - reserved for future use.
/// </summary>
Type: ConstraintExpression
Gen: ConstraintExpression.With=>this.Append(new WithOperator())
%
#
# Constraints Without Arguments
#
/// <summary>
/// Returns a constraint that tests for null
/// </summary>
Type: NullConstraint
Gen: Is.Null=>new NullConstraint()
Gen: ConstraintFactory.Null=>Is.Null
Gen: ConstraintExpression.Null=>(NullConstraint)this.Append(new NullConstraint())
%
/// <summary>
/// Returns a constraint that tests for True
/// </summary>
Type: TrueConstraint
Gen: Is.True=>new TrueConstraint()
Gen: ConstraintFactory.True=>Is.True
Gen: ConstraintExpression.True=>(TrueConstraint)this.Append(new TrueConstraint())
%
/// <summary>
/// Returns a constraint that tests for False
/// </summary>
Type: FalseConstraint
Gen: Is.False=>new FalseConstraint()
Gen: ConstraintFactory.False=>Is.False
Gen: ConstraintExpression.False=>(FalseConstraint)this.Append(new FalseConstraint())
%
/// <summary>
/// Returns a constraint that tests for NaN
/// </summary>
Type: NaNConstraint
Gen: Is.NaN=>new NaNConstraint()
Gen: ConstraintFactory.NaN=>Is.NaN
Gen: ConstraintExpression.NaN=>(NaNConstraint)this.Append(new NaNConstraint())
%
/// <summary>
/// Returns a constraint that tests for empty
/// </summary>
Type: EmptyConstraint
Gen: Is.Empty=>new EmptyConstraint()
Gen: ConstraintFactory.Empty=>Is.Empty
Gen: ConstraintExpression.Empty=>(EmptyConstraint)this.Append(new EmptyConstraint())
%
/// <summary>
/// Returns a constraint that tests whether a collection 
/// contains all unique items.
/// </summary>
Type: UniqueItemsConstraint
Gen: Is.Unique=>new UniqueItemsConstraint()
Gen: ConstraintFactory.Unique=>Is.Unique
Gen: ConstraintExpression.Unique=>(UniqueItemsConstraint)this.Append(new UniqueItemsConstraint())
%
/// <summary>
/// Returns a constraint that tests whether an object graph is serializable in binary format.
/// </summary>
Type: BinarySerializableConstraint
Gen: Is.BinarySerializable=>new BinarySerializableConstraint()
Gen: ConstraintFactory.BinarySerializable=>Is.BinarySerializable
Gen: ConstraintExpression.BinarySerializable=>(BinarySerializableConstraint)this.Append(new BinarySerializableConstraint())
%
/// <summary>
/// Returns a constraint that tests whether an object graph is serializable in xml format.
/// </summary>
Type: XmlSerializableConstraint
Gen: Is.XmlSerializable=>new XmlSerializableConstraint()
Gen: ConstraintFactory.XmlSerializable=>Is.XmlSerializable
Gen: ConstraintExpression.XmlSerializable=>(XmlSerializableConstraint)this.Append(new XmlSerializableConstraint())
%
#
# Constraints Taking an Expected Value 
#
/// <summary>
/// Returns a constraint that tests two items for equality
/// </summary>
Type: EqualConstraint
Gen: Is.EqualTo(object expected)=>new EqualConstraint(expected)
Gen: ConstraintFactory.EqualTo(object expected)=>Is.EqualTo(expected)
Gen: ConstraintExpression.EqualTo(object expected)=>(EqualConstraint)this.Append(new EqualConstraint(expected))
%
/// <summary>
/// Returns a constraint that tests that two references are the same object
/// </summary>
Type: SameAsConstraint
Gen: Is.SameAs(object expected)=>new SameAsConstraint(expected)
Gen: ConstraintFactory.SameAs(object expected)=>Is.SameAs(expected)
Gen: ConstraintExpression.SameAs(object expected)=>(SameAsConstraint)this.Append(new SameAsConstraint(expected))
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is greater than the suppled argument
/// </summary>
Type: GreaterThanConstraint
Gen: Is.GreaterThan(IComparable expected)=>new GreaterThanConstraint(expected)
Gen: ConstraintFactory.GreaterThan(IComparable expected)=>Is.GreaterThan(expected)
Gen: ConstraintExpression.GreaterThan(IComparable expected)=>(GreaterThanConstraint)this.Append(new GreaterThanConstraint(expected))
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is greater than the suppled argument
/// </summary>
Type: GreaterThanOrEqualConstraint
Gen: Is.GreaterThanOrEqualTo(IComparable expected)=>new GreaterThanOrEqualConstraint(expected)
Gen: Is.AtLeast(IComparable expected)=>new GreaterThanOrEqualConstraint(expected)
Gen: ConstraintFactory.GreaterThanOrEqualTo(IComparable expected)=>Is.GreaterThanOrEqualTo(expected)
Gen: ConstraintFactory.AtLeast(IComparable expected)=>Is.AtLeast(expected)
Gen: ConstraintExpression.GreaterThanOrEqualTo(IComparable expected)=>(GreaterThanOrEqualConstraint)this.Append(new GreaterThanOrEqualConstraint(expected))
Gen: ConstraintExpression.AtLeast(IComparable expected)=>GreaterThanOrEqualTo(expected)
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is greater than the suppled argument
/// </summary>
Type: LessThanConstraint
Gen: Is.LessThan(IComparable expected)=>new LessThanConstraint(expected)
Gen: ConstraintFactory.LessThan(IComparable expected)=>Is.LessThan(expected)
Gen: ConstraintExpression.LessThan(IComparable expected)=>(LessThanConstraint)this.Append(new LessThanConstraint(expected))
%
/// <summary>
/// Returns a constraint that tests whether the
/// actual value is greater than the suppled argument
/// </summary>
Type: LessThanOrEqualConstraint
Gen: Is.LessThanOrEqualTo(IComparable expected)=>new LessThanOrEqualConstraint(expected)
Gen: Is.AtMost(IComparable expected)=>new LessThanOrEqualConstraint(expected)
Gen: ConstraintFactory.LessThanOrEqualTo(IComparable expected)=>Is.LessThanOrEqualTo(expected)
Gen: ConstraintFactory.AtMost(IComparable expected)=>Is.AtMost(expected)
Gen: ConstraintExpression.LessThanOrEqualTo(IComparable expected)=>(LessThanOrEqualConstraint)this.Append(new LessThanOrEqualConstraint(expected))
Gen: ConstraintExpression.AtMost(IComparable expected)=>LessThanOrEqualTo(expected)
%
/// <summary>
/// Returns a constraint that tests whether the actual
/// value is of the exact type supplied as an argument.
/// </summary>
Type: ExactTypeConstraint
Gen: Is.TypeOf(Type expectedType)=>new ExactTypeConstraint(expectedType)
Gen: Is.TypeOf<T>()=>TypeOf(typeof(T))
Gen: ConstraintFactory.TypeOf(Type expectedType)=>Is.TypeOf(expectedType)
Gen: ConstraintFactory.TypeOf<T>()=>TypeOf(typeof(T))
Gen: ConstraintExpression.TypeOf(Type expectedType)=>(ExactTypeConstraint)this.Append(new ExactTypeConstraint(expectedType))
Gen: ConstraintExpression.TypeOf<T>()=>TypeOf(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is of the type supplied as an argument or a derived type.
/// </summary>
Type: InstanceOfTypeConstraint
Obs: Is.InstanceOfType(Type expectedType)=>InstanceOf(expectedType)
Obs: Is.InstanceOfType<T>()=>InstanceOf<T>()
Gen: Is.InstanceOf(Type expectedType)=>new InstanceOfTypeConstraint(expectedType)
Gen: Is.InstanceOf<T>()=>new InstanceOfTypeConstraint(typeof(T))
Obs: ConstraintFactory.InstanceOfType(Type expectedType)=>InstanceOf(expectedType)
Obs: ConstraintFactory.InstanceOfType<T>()=>InstanceOf<T>()
Gen: ConstraintFactory.InstanceOf(Type expectedType)=>Is.InstanceOf(expectedType)
Gen: ConstraintFactory.InstanceOf<T>()=>InstanceOf(typeof(T))
Obs: ConstraintExpression.InstanceOfType(Type expectedType)=>InstanceOf(expectedType)
Obs: ConstraintExpression.InstanceOfType<T>()=>InstanceOf<T>()
Gen: ConstraintExpression.InstanceOf(Type expectedType)=>(InstanceOfTypeConstraint)this.Append(new InstanceOfTypeConstraint(expectedType))
Gen: ConstraintExpression.InstanceOf<T>()=>InstanceOf(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is assignable from the type supplied as an argument.
/// </summary>
Type: AssignableFromConstraint
Gen: Is.AssignableFrom(Type expectedType)=>new AssignableFromConstraint(expectedType)
Gen: Is.AssignableFrom<T>()=>AssignableFrom(typeof(T))
Gen: ConstraintFactory.AssignableFrom(Type expectedType)=>Is.AssignableFrom(expectedType)
Gen: ConstraintFactory.AssignableFrom<T>()=>AssignableFrom(typeof(T))
Gen: ConstraintExpression.AssignableFrom(Type expectedType)=>(AssignableFromConstraint)this.Append(new AssignableFromConstraint(expectedType))
Gen: ConstraintExpression.AssignableFrom<T>()=>AssignableFrom(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is assignable from the type supplied as an argument.
/// </summary>
Type: AssignableToConstraint
Gen: Is.AssignableTo(Type expectedType)=>new AssignableToConstraint(expectedType)
Gen: Is.AssignableTo<T>()=>AssignableTo(typeof(T))
Gen: ConstraintFactory.AssignableTo(Type expectedType)=>Is.AssignableTo(expectedType)
Gen: ConstraintFactory.AssignableTo<T>()=>AssignableTo(typeof(T))
Gen: ConstraintExpression.AssignableTo(Type expectedType)=>(AssignableToConstraint)this.Append(new AssignableToConstraint(expectedType))
Gen: ConstraintExpression.AssignableTo<T>()=>AssignableTo(typeof(T))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is a collection containing the same elements as the 
/// collection supplied as an argument.
/// </summary>
Type: CollectionEquivalentConstraint
Gen: Is.EquivalentTo(IEnumerable expected)=>new CollectionEquivalentConstraint(expected)
Gen: ConstraintFactory.EquivalentTo(IEnumerable expected)=>Is.EquivalentTo(expected)
Gen: ConstraintExpression.EquivalentTo(IEnumerable expected)=>(CollectionEquivalentConstraint)this.Append(Is.EquivalentTo(expected))
%
/// <summary>
/// Returns a constraint that tests whether the actual value
/// is a subset of the collection supplied as an argument.
/// </summary>
Type: CollectionSubsetConstraint
Gen: Is.SubsetOf(IEnumerable expected)=>new CollectionSubsetConstraint(expected)
Gen: ConstraintFactory.SubsetOf(IEnumerable expected)=>Is.SubsetOf(expected)
Gen: ConstraintExpression.SubsetOf(IEnumerable expected)=>(CollectionSubsetConstraint)this.Append(Is.SubsetOf(expected))
%
/// <summary>
/// Returns a constraint that tests whether a collection is ordered
/// </summary>
Type: CollectionOrderedConstraint
Gen: Is.Ordered()=>new CollectionOrderedConstraint()
Gen: Is.Ordered(IComparer comparer)=>new CollectionOrderedConstraint(comparer)
Gen: Is.OrderedBy(string propertyName)=>new CollectionOrderedConstraint(propertyName)
Gen: Is.OrderedBy(string propertyName, IComparer comparer)=>new CollectionOrderedConstraint(propertyName, comparer)
Gen: ConstraintFactory.Ordered()=>Is.Ordered()
Gen: ConstraintFactory.Ordered(IComparer comparer)=>Is.Ordered(comparer)
Gen: ConstraintFactory.OrderedBy(string propertyName)=>Is.OrderedBy(propertyName)
Gen: ConstraintFactory.OrderedBy(string propertyName, IComparer comparer)=>Is.OrderedBy(propertyName, comparer)
Gen: ConstraintExpression.Ordered()=>(CollectionOrderedConstraint)this.Append(new CollectionOrderedConstraint())
Gen: ConstraintExpression.Ordered(IComparer comparer)=>(CollectionOrderedConstraint)this.Append(new CollectionOrderedConstraint(comparer))
Gen: ConstraintExpression.OrderedBy(string propertyName)=>(CollectionOrderedConstraint)this.Append(new CollectionOrderedConstraint(propertyName))
Gen: ConstraintExpression.OrderedBy(string propertyName, IComparer comparer)=>(CollectionOrderedConstraint)this.Append(new CollectionOrderedConstraint(propertyName, comparer))
%
/// <summary>
/// Returns a new CollectionContainsConstraint checking for the
/// presence of a particular object in the collection.
/// </summary>
Type: CollectionContainsConstraint
Gen: Has.Member(object expected)=>new CollectionContainsConstraint( expected )
Gen: ConstraintFactory.Contains(object expected)=>new CollectionContainsConstraint(expected)
Gen: ConstraintFactory.Member(object expected)=>new CollectionContainsConstraint(expected)
Gen: ConstraintExpression.Contains(object expected)=>(CollectionContainsConstraint)this.Append(new CollectionContainsConstraint(expected))
Gen: ConstraintExpression.Member(object expected)=>(CollectionContainsConstraint)this.Append(new CollectionContainsConstraint(expected))
%
/// <summary>
/// Returns a new ContainsConstraint. This constraint
/// will, in turn, make use of the appropriate second-level
/// constraint, depending on the type of the actual argument. 
/// This overload is only used if the item sought is a string,
/// since any other type implies that we are looking for a 
//// collection member.
/// </summary>
Type: ContainsConstraint
Gen: ConstraintFactory.Contains(string expected)=>new ContainsConstraint(expected)
Gen: ConstraintExpression.Contains(string expected)=>(ContainsConstraint)this.Append(new ContainsConstraint(expected))
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value contains the substring supplied as an argument.
/// </summary>
Type: SubstringConstraint
Gen: Text.Contains(string expected)=>new SubstringConstraint(expected)
Gen: ConstraintFactory.ContainsSubstring(string expected)=>Text.Contains(expected)
Gen: ConstraintExpression.ContainsSubstring(string expected)=>(SubstringConstraint)this.Append(Text.Contains(expected))
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value contains the substring supplied as an argument.
/// </summary>
Type: SubstringConstraint
Gen: Text.DoesNotContain(string expected)=>new ConstraintExpression().Not.ContainsSubstring(expected)
Gen: ConstraintFactory.DoesNotContain(string expected)=>Text.DoesNotContain(expected)
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value starts with the substring supplied as an argument.
/// </summary>
Type: StartsWithConstraint
Gen: Text.StartsWith(string expected)=>new StartsWithConstraint(expected)
Gen: ConstraintFactory.StartsWith(string expected)=>Text.StartsWith(expected)
Gen: ConstraintExpression.StartsWith(string expected)=>(StartsWithConstraint)this.Append(Text.StartsWith(expected))
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value starts with the substring supplied as an argument.
/// </summary>
Type: StartsWithConstraint
Gen: Text.DoesNotStartWith(string expected)=>new ConstraintExpression().Not.StartsWith(expected)
Gen: ConstraintFactory.DoesNotStartWith(string expected)=>Text.DoesNotStartWith(expected)
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value ends with the substring supplied as an argument.
/// </summary>
Type: EndsWithConstraint
Gen: Text.EndsWith(string expected)=>new EndsWithConstraint(expected)
Gen: ConstraintFactory.EndsWith(string expected)=>Text.EndsWith(expected)
Gen: ConstraintExpression.EndsWith(string expected)=>(EndsWithConstraint)this.Append(Text.EndsWith(expected))
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value ends with the substring supplied as an argument.
/// </summary>
Type: EndsWithConstraint
Gen: Text.DoesNotEndWith(string expected)=>new ConstraintExpression().Not.EndsWith(expected)
Gen: ConstraintFactory.DoesNotEndWith(string expected)=>Text.DoesNotEndWith(expected)
%
/// <summary>
/// Returns a constraint that succeeds if the actual
/// value matches the pattern supplied as an argument.
/// </summary>
Type: RegexConstraint
Gen: Text.Matches(string pattern)=>new RegexConstraint(pattern)
Gen: ConstraintFactory.Matches(string pattern)=>Text.Matches(pattern)
Gen: ConstraintExpression.Matches(string pattern)=>(RegexConstraint)this.Append(Text.Matches(pattern))
%
/// <summary>
/// Returns a constraint that fails if the actual
/// value matches the pattern supplied as an argument.
/// </summary>
Type: RegexConstraint
Gen: Text.DoesNotMatch(string pattern)=>new ConstraintExpression().Not.Matches(pattern)
Gen: ConstraintFactory.DoesNotMatch(string pattern)=>Text.DoesNotMatch(pattern)
%
/// <summary>
/// Returns a constraint that tests whether the path provided 
/// is the same as an expected path after canonicalization.
/// </summary>
Type: SamePathConstraint
Gen: Is.SamePath(string expected)=>new SamePathConstraint(expected)
Gen: ConstraintFactory.SamePath(string expected)=>Is.SamePath(expected)
Gen: ConstraintExpression.SamePath(string expected)=>(SamePathConstraint)this.Append(Is.SamePath(expected))
%
/// <summary>
/// Returns a constraint that tests whether the path provided 
/// is the same path or under an expected path after canonicalization.
/// </summary>
Type: SamePathOrUnderConstraint
Gen: Is.SamePathOrUnder(string expected)=>new SamePathOrUnderConstraint(expected)
Gen: ConstraintFactory.SamePathOrUnder(string expected)=>Is.SamePathOrUnder(expected)
Gen: ConstraintExpression.SamePathOrUnder(string expected)=>(SamePathOrUnderConstraint)this.Append(Is.SamePathOrUnder(expected))
%
#
# Constraints with Two Arguments
#
/// <summary>
/// Returns a constraint that tests whether the actual value falls 
/// within a specified range.
/// </summary>
Type: RangeConstraint
Gen: Is.InRange(IComparable from, IComparable to)=>new RangeConstraint(from, to)
Gen: ConstraintFactory.InRange(IComparable from, IComparable to)=>Is.InRange(from, to)
Gen: ConstraintExpression.InRange(IComparable from, IComparable to)=>(RangeConstraint)this.Append(Is.InRange(from, to))
#
# These may need to be hand-coded
#Throws